#!/usr/bin/env bash
set -euo pipefail

# Constants
readonly OCDEV_DIR="${HOME}/.ocdev"
readonly PORTS_FILE="${OCDEV_DIR}/ports"
readonly LOCK_FILE="${OCDEV_DIR}/.lock"
readonly CONTAINER_PREFIX="ocdev-"
readonly PROFILE_NAME="ocdev"
readonly BASE_IMAGE="images:ubuntu/25.10"
readonly SSH_PORT_START=2201

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_PREREQ=2
readonly EXIT_NOT_FOUND=3
readonly EXIT_NOT_RUNNING=4

#######################################
# Output Helpers
#######################################

info() { echo "[INFO] $*" >&2; }
warn() { echo "[WARN] $*" >&2; }
error() { echo "[ERROR] $*" >&2; }
success() { echo "[OK] $*"; }
die() { error "$*"; exit $EXIT_ERROR; }

#######################################
# Usage
#######################################

usage() {
    cat <<EOF
ocdev - Manage isolated development environments using Incus containers

USAGE:
    ocdev <command> [arguments]

COMMANDS:
    create <name>    Create a new development container
    list             List all ocdev containers
    start <name>     Start a stopped container
    stop <name>      Stop a running container
    shell <name>     Open interactive shell in container
    ssh <name>       Display SSH connection info
    delete <name>    Delete a container
    ports            List all port allocations

OPTIONS:
    -h, --help       Show this help message

EXAMPLES:
    ocdev create myproject    # Create new container
    ocdev shell myproject     # Open shell
    ocdev ssh myproject       # Show SSH command
    ocdev delete myproject    # Delete container
EOF
}

#######################################
# Prerequisite Checks
#######################################

check_prerequisites() {
    # Check incus command
    command -v incus &>/dev/null || { error "incus not found. Please install Incus."; exit $EXIT_PREREQ; }
    
    # Check group membership
    groups | grep -qw incus-admin || { error "User not in incus-admin group."; exit $EXIT_PREREQ; }
    
    # Ensure ocdev directory
    mkdir -p "$OCDEV_DIR"
    touch "$PORTS_FILE"
}

#######################################
# Profile Manager
#######################################

ensure_profile() {
    if ! incus profile show "$PROFILE_NAME" &>/dev/null; then
        info "Creating ocdev profile..."
        incus profile create "$PROFILE_NAME"
        incus profile set "$PROFILE_NAME" security.nesting=true
        incus profile set "$PROFILE_NAME" security.syscalls.intercept.mknod=true
        incus profile set "$PROFILE_NAME" security.syscalls.intercept.setxattr=true
    fi
}

#######################################
# Helper Functions
#######################################

# Check if container exists
container_exists() {
    incus info "$1" &>/dev/null
}

# Check if container is running
container_running() {
    local state
    state=$(incus info "$1" 2>/dev/null | grep -E "^Status:" | awk '{print $2}')
    [[ "$state" == "RUNNING" ]]
}

# Validate container name
validate_name() {
    local name="$1"
    [[ "$name" =~ ^[a-zA-Z][a-zA-Z0-9-]*$ ]] || die "Invalid name: must start with letter, contain only alphanumeric and hyphens"
    [[ ${#name} -le 50 ]] || die "Invalid name: too long (max 50 chars)"
}

#######################################
# Port Management
#######################################

# Allocate next available port (must be called within flock context)
allocate_port() {
    local port=$SSH_PORT_START
    local max_port=65535
    
    while grep -Fq ":${port}" "$PORTS_FILE" 2>/dev/null; do
        ((port++))
        if [[ $port -gt $max_port ]]; then
            die "No available ports (all ports from $SSH_PORT_START to $max_port are allocated)"
        fi
    done
    
    echo "$port"
}

remove_port() {
    local name="$1"
    
    (
        flock -x 200
        local temp
        temp=$(grep -Fv "${name}:" "$PORTS_FILE" 2>/dev/null || true)
        if [[ -n "$temp" ]]; then
            printf '%s\n' "$temp" > "$PORTS_FILE"
        else
            : > "$PORTS_FILE"
        fi
    ) 200>"$LOCK_FILE"
}

get_port() {
    local name="$1"
    grep -F "${name}:" "$PORTS_FILE" 2>/dev/null | head -1 | cut -d: -f2
}

#######################################
# Container Commands
#######################################

cmd_create() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev create <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    local port=""
    local host_uid=$(id -u)
    
    # Validate name
    validate_name "$name"
    
    # Check container doesn't exist
    if container_exists "$container"; then
        die "Container '$name' already exists"
    fi
    
    # Ensure profile exists
    ensure_profile
    
    # Allocate port with lock (use file descriptor for flock without subshell)
    exec 200>"$LOCK_FILE"
    flock -x 200
    port=$(allocate_port)
    
    # Trap for cleanup on failure
    cleanup() {
        # Check if container exists before trying to delete
        if [[ -n "${container:-}" ]] && incus info "$container" &>/dev/null; then
            warn "Cleaning up failed container..."
            incus delete --force "$container" 2>/dev/null || true
        fi
        # Release lock
        flock -u 200 2>/dev/null || true
    }
    trap cleanup EXIT
    
    info "Creating container '$name' with SSH port $port..."
    
    # Launch container
    incus launch "$BASE_IMAGE" "$container" --profile default --profile "$PROFILE_NAME"
    
    # Add disk devices
    info "Configuring disk mounts..."
    
    if [[ -d "${HOME}/.config" ]]; then
        incus config device add "$container" host-config disk \
            source="${HOME}/.config" \
            path=/home/dev/.config \
            shift=true
    fi
    
    if [[ -d "${HOME}/.opencode" ]]; then
        incus config device add "$container" host-opencode disk \
            source="${HOME}/.opencode" \
            path=/home/dev/.opencode \
            shift=true
    fi
    
    if [[ -d "${HOME}/.ssh" ]]; then
        incus config device add "$container" host-ssh disk \
            source="${HOME}/.ssh" \
            path=/home/dev/.ssh \
            readonly=true \
            shift=true
    fi
    
    if [[ -f "${HOME}/.gitconfig" ]]; then
        incus config device add "$container" host-gitconfig disk \
            source="${HOME}/.gitconfig" \
            path=/home/dev/.gitconfig \
            readonly=true \
            shift=true
    fi
    
    # Add SSH proxy device
    info "Configuring SSH proxy on port $port..."
    incus config device add "$container" ssh-proxy proxy \
        listen=tcp:0.0.0.0:${port} \
        connect=tcp:127.0.0.1:22 \
        bind=host
    
    # Run provisioning script
    info "Provisioning container (this may take a few minutes)..."
    incus exec "$container" -- bash <<PROVISION
set -e

# Wait for network (up to 60 seconds)
network_ready=false
for i in {1..60}; do
    if ping -c1 -W1 archive.ubuntu.com &>/dev/null; then
        network_ready=true
        break
    fi
    sleep 1
done

if [[ "\$network_ready" != "true" ]]; then
    echo "ERROR: Network not available after 60 seconds" >&2
    exit 1
fi

# Update and install packages
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get install -y --no-install-recommends \
    openssh-server \
    docker.io \
    docker-compose \
    curl \
    git \
    ca-certificates \
    sudo

# Create dev user with matching UID
# Remove any existing user with target UID (e.g., ubuntu user has UID 1000)
existing_user=\$(getent passwd $host_uid | cut -d: -f1)
if [[ -n "\$existing_user" ]]; then
    userdel -r "\$existing_user" 2>/dev/null || true
fi
useradd -m -s /bin/bash -u $host_uid dev
usermod -aG docker dev

# Configure passwordless sudo for dev user
echo 'dev ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/dev
chmod 440 /etc/sudoers.d/dev

# Configure SSH for dev user login (handle both commented and uncommented cases)
sed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
sed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
# SSH directory setup:
# - If host ~/.ssh exists, it's mounted read-only with shift=true, so permissions
#   are inherited from host and UID mapping is handled automatically.
# - If host ~/.ssh doesn't exist, no mount is created and SSH key auth won't be
#   available (user can set up keys manually if needed).

# Enable and start services
systemctl enable ssh docker
systemctl start ssh docker
PROVISION
    
    # Success - save port then disable cleanup trap
    echo "${name}:${port}" >> "$PORTS_FILE"
    trap - EXIT
    
    # Release lock
    flock -u 200
    
    success "Container '$name' created (SSH port: $port)"
}

cmd_list() {
    local containers
    
    # Capture both stdout and stderr, check exit status
    if ! containers=$(incus list --format=csv -c n,s "${CONTAINER_PREFIX}" 2>&1); then
        # Check if it's a real error vs just empty results
        if [[ -n "$containers" ]] && [[ ! "$containers" =~ "No container" ]]; then
            error "Failed to list containers: $containers"
            exit $EXIT_ERROR
        fi
        containers=""
    fi
    
    containers=$(printf '%s\n' "$containers" | sort)
    
    printf "%-20s %-10s %s\n" "NAME" "STATUS" "SSH PORT"
    
    while IFS=, read -r container_name status; do
        [[ -z "$container_name" ]] && continue
        local name="${container_name#${CONTAINER_PREFIX}}"
        local port
        port=$(get_port "$name")
        printf "%-20s %-10s %s\n" "$name" "$status" "${port:-N/A}"
    done <<< "$containers"
}

cmd_start() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev start <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    
    container_exists "$container" || { error "Container '$name' not found"; exit $EXIT_NOT_FOUND; }
    
    if container_running "$container"; then
        info "Container '$name' is already running"
        return $EXIT_SUCCESS
    fi
    
    incus start "$container"
    success "Container '$name' started"
}

cmd_stop() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev stop <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    
    container_exists "$container" || { error "Container '$name' not found"; exit $EXIT_NOT_FOUND; }
    
    if ! container_running "$container"; then
        info "Container '$name' is already stopped"
        return $EXIT_SUCCESS
    fi
    
    incus stop "$container"
    success "Container '$name' stopped"
}

cmd_shell() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev shell <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    
    container_exists "$container" || { error "Container '$name' not found"; exit $EXIT_NOT_FOUND; }
    
    if ! container_running "$container"; then
        error "Container '$name' is not running. Use 'ocdev start $name' first."
        exit $EXIT_NOT_RUNNING
    fi
    
    exec incus exec "$container" -- su --login dev
}

cmd_ssh() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev ssh <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    
    container_exists "$container" || { error "Container '$name' not found"; exit $EXIT_NOT_FOUND; }
    
    local port
    port=$(get_port "$name")
    [[ -z "$port" ]] && die "No SSH port found for '$name'"
    
    echo "ssh -p $port dev@localhost"
    echo ""
    echo "Or add to ~/.ssh/config:"
    echo ""
    echo "Host $name"
    echo "    HostName localhost"
    echo "    Port $port"
    echo "    User dev"
}

cmd_delete() {
    [[ $# -lt 1 ]] && { error "Usage: ocdev delete <name>"; exit $EXIT_ERROR; }
    
    local name="$1"
    local container="${CONTAINER_PREFIX}${name}"
    
    container_exists "$container" || { error "Container '$name' not found"; exit $EXIT_NOT_FOUND; }
    
    # Force stop if running
    if container_running "$container"; then
        info "Stopping container..."
        incus stop "$container"
    fi
    
    # Delete container
    incus delete "$container"
    
    # Remove port allocation
    remove_port "$name"
    
    success "Container '$name' deleted"
}

cmd_ports() {
    printf "%-20s %-6s %s\n" "NAME" "PORT" "STATUS"
    
    # Use shared lock for consistent read
    (
        flock -s 200
        while IFS=: read -r name port; do
            [[ -z "$name" ]] && continue
            container="${CONTAINER_PREFIX}${name}"
            status=""
            
            if ! incus info "$container" &>/dev/null; then
                status="DELETED"
            elif container_running "$container"; then
                status="RUNNING"
            else
                status="STOPPED"
            fi
            
            printf "%-20s %-6s %s\n" "$name" "$port" "$status"
        done < "$PORTS_FILE"
    ) 200>"$LOCK_FILE"
}

#######################################
# Main Dispatcher
#######################################

main() {
    [[ $# -lt 1 ]] && usage && exit $EXIT_ERROR
    
    local cmd="$1"
    shift
    
    case "$cmd" in
        create|list|start|stop|shell|ssh|delete|ports)
            check_prerequisites
            "cmd_${cmd}" "$@"
            ;;
        -h|--help|help)
            usage
            ;;
        *)
            error "Unknown command: $cmd"
            usage
            exit $EXIT_ERROR
            ;;
    esac
}

main "$@"
